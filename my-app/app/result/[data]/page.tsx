"use client";

import GraphView from "./graph-view";
import { Node, Edge } from "react-vis-graph-wrapper";
import { useSearchParams } from "next/navigation";
import { AiFillHome } from "react-icons/ai";
import Link from "next/link";
import InfoModal from "./about-grounded";

export type GraphData = {
  nodes: Node[];
  edges: Edge[];
};
//the graph page
export default function Page({ params }: { params: { data: string } }) {
  const searchParams = useSearchParams();
  const search = searchParams.get("labelling");
  let labelling = "N";
  if (search) {
    labelling = search;
  }
  let mod: GraphData = {
    nodes: [],
    edges: [],
  };
  //obtain graph data from URI
  const str = decodeURIComponent(params.data);
  //turn it into an object
  mod = JSON.parse(str);
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-24">
      <h1>Argument Labelling</h1>
      <Link href={"/"} className="home-button">
        <AiFillHome />
      </Link>
      <ul className="labellings">
        <li className="labellings">Choose framework semantics:</li>
        <li className="labellings">
          <Link className="grounded" href={"/result/" + str + "?labelling=G"}>
            Grounded
          </Link>
          <InfoModal title={groundedTitle} info={groundedInfo} />
        </li>
        <li className="labellings">
          <Link className="admissible" href={"/result/" + str + "?labelling=A"}>
            Admissible
          </Link>
          <InfoModal title={adTitle} info={adInfo} />
        </li>
        <li className="labellings">
          <Link className="preferred" href={"/result/" + str + "?labelling=P"}>
            Preferred
          </Link>
          <InfoModal title={preTitle} info={preInfo} />
        </li>
      </ul>
      <GraphView data={mod} labelling={labelling} />
    </main>
  );
}

//Info for modal
const groundedTitle = "The Grounded Algorithm";
const groundedInfo =
  "For any argumentation framework, there is guaranteed to be exactly one grounded extension. The Grounded semantics provides a way to identify a minimal and conflict-free set of arguments that are accepted based on the given Dung graph. To compute the Grounded set, you start with an initially empty set of accepted arguments. Then, iteratively, you add arguments that are directly attacked by arguments in the accepted set until no more arguments can be added. An argument is added to the Grounded set if all its attackers are already in the set. The resulting set contains arguments that cannot be attacked by any other arguments in the framework, and adding any other argument would lead to conflicts.";
const adTitle = "The Admissible Algorithm";
const adInfo =
  "Admissible labellings are generated by starting with a labelling that labels all arguments as IN. The algorithm iteratively selects arguments that are illegally IN and applies a transition step to obtain a new labelling. This process continues until a labelling is reached where no argument is illegally IN. A transition sequence is utilized, consisting of a series of labellings where each subsequent labelling is obtained by applying a transition step to an argument that is illegally IN in the previous labelling.";
const preTitle = "The Preferred Algorithm";
const preInfo =
  "On the other hand, aims to identify sets of arguments that are not only conflict-free but also maximally preferred according to certain criteria. To compute the Preferred sets, various approaches can be employed, but one common method is to rank arguments based on some preference relation or ordering, such as specificity, strength of evidence, or external criteria. Then, preferred sets consist of arguments that are acceptable and maximise some notion of preference. Unlike the Grounded set, which is minimal and conflict-free, preferred sets aim to capture arguments that are not only acceptable but also preferred among multiple possible acceptable sets (Hence, some graphs having more than one solution being displayed). A preferred labelling is also defined as an admissible labelling that maximizes the number of arguments legally labeled as IN. The computation of preferred extensions is equivalent to identifying admissible labellings that maximize legally IN arguments, establishing a direct link between admissible and preferred labellings.";
